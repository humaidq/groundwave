    </main>
<!--    <footer>
      <p>Groundwave is released under Apache 2.0 license.</p>
      <p><a href="https://huma.id/groundwave">View source</a></p>
    </footer>-->
    {{ if .IsZettelkasten }}
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false},
                  {left: '\\[', right: '\\]', display: true}
              ],
              throwOnError : false
            });
        });
    </script>
    {{ end }}
    {{ if .EnableTimestampCountdown }}
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        const timestamps = document.querySelectorAll("span.timestamp");
        if (!timestamps.length) {
          return;
        }

        function parseTimestamp(text) {
          const match = text.match(/<\s*(\d{4})-(\d{2})-(\d{2})(?:\s+\w{3})?(?:\s+(\d{2}):(\d{2}))?.*>/);
          if (!match) {
            return null;
          }
          const year = parseInt(match[1], 10);
          const month = parseInt(match[2], 10) - 1;
          const day = parseInt(match[3], 10);
          const hasTime = match[4] && match[5];
          const hour = hasTime ? parseInt(match[4], 10) : 23;
          const minute = hasTime ? parseInt(match[5], 10) : 59;
          return new Date(year, month, day, hour, minute, 0);
        }

        function formatDuration(ms) {
          const absMs = Math.abs(ms);
          const totalMinutes = Math.floor(absMs / 60000);
          const days = Math.floor(totalMinutes / 1440);
          const hours = Math.floor((totalMinutes % 1440) / 60);
          const minutes = totalMinutes % 60;
          const parts = [];
          if (days > 0) {
            parts.push(days + "d");
          }
          if (days > 0 || hours > 0) {
            parts.push(hours + "h");
          }
          parts.push(minutes + "m");
          return parts.join(" ");
        }

        function updateCountdown(entry) {
          const now = new Date();
          const diff = entry.target - now;
          const label = diff >= 0 ? "in " + formatDuration(diff) : "elapsed " + formatDuration(diff);
          entry.element.textContent = label;
          entry.element.classList.remove("countdown-future", "countdown-soon", "countdown-past");
          if (diff < 0) {
            entry.element.classList.add("countdown-past");
            return;
          }
          if (diff <= 24 * 60 * 60 * 1000) {
            entry.element.classList.add("countdown-soon");
          } else {
            entry.element.classList.add("countdown-future");
          }
        }

        const entries = [];
        timestamps.forEach(function(node) {
          if (node.dataset.countdownAttached) {
            return;
          }
          const target = parseTimestamp(node.textContent || "");
          if (!target) {
            return;
          }
          node.dataset.countdownAttached = "true";
          const countdown = document.createElement("span");
          countdown.className = "timestamp-countdown";
          node.insertAdjacentElement("afterend", countdown);
          entries.push({
            target: target,
            element: countdown,
          });
          updateCountdown(entries[entries.length - 1]);
        });

        if (!entries.length) {
          return;
        }

        setInterval(function() {
          entries.forEach(updateCountdown);
        }, 60000);
      });
    </script>
    {{ end }}
    <script>
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js');
      }
    </script>
    {{ if .EnableAutocomplete }}
    <script>
      // Reusable Autocomplete Component
      function initAutocomplete(inputSelector, items) {
        const inputs = document.querySelectorAll(inputSelector);

        inputs.forEach(function(input) {
          const container = input.closest('.autocomplete-container');
          if (!container) return;

          const dropdown = container.querySelector('.autocomplete-dropdown');
          if (!dropdown) return;

          let selectedIndex = -1;

          function renderItems(filter) {
            const query = (filter || '').toLowerCase();
            const filtered = items.filter(function(item) {
              return item.toLowerCase().includes(query);
            });

            if (filtered.length === 0) {
              dropdown.innerHTML = '<div class="autocomplete-empty">No matches found</div>';
              return;
            }

            dropdown.innerHTML = filtered.map(function(item, index) {
              const highlighted = query ? item.replace(
                new RegExp('(' + query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi'),
                '<span class="autocomplete-item-highlight">$1</span>'
              ) : item;
              return '<div class="autocomplete-item" data-value="' + item + '" data-index="' + index + '">' + highlighted + '</div>';
            }).join('');

            selectedIndex = -1;
          }

          function showDropdown() {
            renderItems(input.value);
            dropdown.classList.add('show');
          }

          function hideDropdown() {
            dropdown.classList.remove('show');
            selectedIndex = -1;
          }

          function selectItem(value) {
            input.value = value;
            hideDropdown();
            input.focus();
          }

          function updateSelection() {
            const items = dropdown.querySelectorAll('.autocomplete-item');
            items.forEach(function(item, index) {
              item.classList.toggle('selected', index === selectedIndex);
            });
            if (selectedIndex >= 0 && items[selectedIndex]) {
              items[selectedIndex].scrollIntoView({ block: 'nearest' });
            }
          }

          input.addEventListener('focus', showDropdown);

          input.addEventListener('input', function() {
            renderItems(input.value);
            if (!dropdown.classList.contains('show')) {
              dropdown.classList.add('show');
            }
          });

          input.addEventListener('keydown', function(e) {
            // Only handle keys if dropdown is visible
            if (!dropdown.classList.contains('show')) {
              return; // Let default behavior happen
            }

            const items = dropdown.querySelectorAll('.autocomplete-item');

            if (e.key === 'ArrowDown') {
              e.preventDefault();
              selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
              updateSelection();
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              selectedIndex = Math.max(selectedIndex - 1, -1);
              updateSelection();
            } else if (e.key === 'Enter' || e.key === 'Tab') {
              // If one result or item selected, auto-complete
              if (items.length === 1) {
                e.preventDefault();
                selectItem(items[0].dataset.value);
              } else if (selectedIndex >= 0 && items[selectedIndex]) {
                e.preventDefault();
                selectItem(items[selectedIndex].dataset.value);
              }
              // Otherwise let default behavior happen (Tab moves focus, Enter submits)
            } else if (e.key === 'Escape') {
              hideDropdown();
            }
          });

          dropdown.addEventListener('mousedown', function(e) {
            e.preventDefault(); // Prevent input blur
          });

          dropdown.addEventListener('click', function(e) {
            const item = e.target.closest('.autocomplete-item');
            if (item) {
              selectItem(item.dataset.value);
            }
          });

          document.addEventListener('click', function(e) {
            if (!container.contains(e.target)) {
              hideDropdown();
            }
          });
        });
      }
    </script>
    {{ end }}
  </body>
</html>
